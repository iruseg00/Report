<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
    <title>Доклад №1</title>
  </head>
  <body>
    <header>
      <div class="popup">
        <h1 class="popup_title">
          Проектирование интерфейсов для мобильных устройств
        </h1>
      </div>
    </header>
    <section>
      <h3 class="title">
        Принципы и способы построения графического интерфейса мобильного
        приложения.
      </h3>
      <p class="content">
        Интерфейс — общая граница между двумя функциональными объектами,
        требования к которой определяются стандартом; совокупность средств,
        методов и правил взаимодействия (управления, контроля и т. д.) между
        элементами системы.
      </p>
      <p class="content">
        Для того, чтобы быть полезными, мобильные приложения должны быть
        ориентированными на пользователя. Пользователи устанавливают ваше
        приложение, потому что хотят решить какие-то проблемы. Таким образом,
        приложение имеет ярко выраженную «целеустремленность» Подумайте о том,
        чего ваши пользователи будут пытаться достичь и сосредоточьтесь на их
        основных целях. Уберите с их пути все препятствия.
      </p>
      <p class="content">
        Также при разработке интерфейса разработчики должны принести ясность в
        свой UI. Чтобы эффективно решать свои задачи, используя ваш интерфейс,
        люди должны понимать, как его использовать. Там просто не должно быть
        места для путаницы.
      </p>
      <div class="content-list">
        <p class="content">
          Таким образом, при разработке интерфейса мобильного приложения стоит
          следовать следующим правилам:
        </p>
        <ol class="list">
          <li>
            Удалить беспорядок (в интерфейсе не должно быть нагромождений и
            функций, которые будут не так важны для пользователя, как основные.
            Простое правило: по одному основному действию на экран);
          </li>
          <li>
            Навигация должна быть очевидной (необходимо соблюдать
            последовательность при переходе от одной функции приложения к другой
            и обратно, чтобы у пользователя не возникало трудностей в навигации.
            Также, хорошим тоном будет использовать говорящие иконки и названия
            элементов управления);
          </li>
          <li>
            Удобство элементов управления (необходимо учитывать удобство
            элементов управления при использовании на относительно небольших
            экранах мобильных устройств. Размеры кнопок и других элементов
            управления должны быть такими, чтобы их удобно было читать, нажимать
            и выполнять с ними различные другие действия);
          </li>
        </ol>
      </div>
      <p class="content">
        Используя эти правила можно разработать хороший графический интерфейс
        для вашего приложения. А для создания самих прототипов графического
        интерфейса можно использовать множество специализированного ПО, таких
        как Figma, Mockplus, InVision и другие. Многие из них имеют в своём
        составе множество оформленных по всем стандартам элементов управления и
        помогут более эффективно строить интерфейс.
      </p>
      <p class="content">
        Элементы управления - это доступные для манипулирования самодостаточные
        экранные объекты, посредством которых люди взаимодействуют с цифровыми
        продуктами. Элементы управления (controls, другое название - widgets -
        сокращение от windows gadgets - оконные приспособления) - это базовые
        строительные блоки графического пользовательского интерфейса.
      </p>
      <p class="content">
        <span>
          Рассматривая элементы управления с учетом целей пользователя, их можно
          разбить на четыре основные категории:
        </span>
        <ol class="list">
          <li>Командные элементы управления, применяемые для выполнения функций;</li>
          <li>Элементы выбора, позволяющие выбирать данные или настройки;</li>
          <li>Элементы ввода, применяемые для ввода данных;</li>
          <li>
            Элементы отображения, используемые для наглядного непосредственного
            манипулирования.
          </li>
        </ol>
      </p>
    </section>
    <section>
      <h3 class="title">
        Командные элементы управления
      </h3>
      <p class="content">
        К этим элементам относятся кнопки, кнопки-значки, гиперссылки.
      </p>
      <p class="content">
        Кнопка - удобный и привлекательный с визуальной точки зрения элемент управления. Весь ее облик подсказывает, что на нее можно нажать, и это характеризует ее ожидаемое назначение. Рекомендуется изменять внешний вид нажатой кнопки, так как это облегчает понимание работы программы пользователем.
      </p>
      <p class="img">
        <img src="./image/1.jpg" alt="img">
      </p>
      <p class="content">
        Кнопки, помещенные на панель инструментов, обычно становятся квадратными, теряют текстовую надпись и обзаводятся пиктограммой - пояснением в виде графического значка. Считается, что кнопки-значки очень удобны: они постоянно на виду и взаимодействовать с ними проще, чем с элементами раскрывающегося меню. Поскольку они постоянно видны, то легко запоминаются. У большинства пользователей не возникает вопросов относительно ожидаемого назначения кнопки. Проблема в том, что изображение на кнопке иногда бывает непонятным. Например, пиктограмма с изображением дискеты, традиционно обозначающая сохранение, часто непонятна молодым пользователям, которые никогда не работали с реальными дискетами.
      </p>
      <p class="img">
        <img src="./image/2.jpg" alt="img">
      </p>
      <p class="content">
        Текстовые гиперссылки - распространенный способ навигации в сети и веб-приложениях, однако при программировании для мобильных устройств их следует избегать. Дело в том, что попасть по ссылке пальцем с первого раза часто затруднительно и пользователей раздражает необходимость повторения этих действий.
      </p>
    </section>
    <section>
      <h3 class="title">
        Элементы управления выбором
      </h3>
      <p class="content">
        Элементы выбора позволяют пользователю выбрать из группы допустимых объектов тот, с которым будет совершено действие. Элементы выбора применяются также для действий по настройке. Распространенными элементами выбора являются флажки и списки.
      </p>
      <p class="content">
        Назначение флажка очевидно. Щелкнув по флажку, пользователь немедленно увидит появившуюся галочку. Флажок прост, нагляден и изящен, однако основан на тексте. Качественный текст может исключить возможность неоднозначного толкования флажка. Однако этот же поясняющий текст вынуждает пользователя замедляться для прочтения, а также занимает значительное экранное пространство. Традиционно флажки имеют квадратную форму. Не забывайте, что пользователи распознают визуальные объекты по форме, и квадратная форма флажков - важный стандарт.
      </p>
      <p class="content">
        Существует возможность сделать флажок более наглядным, применив в качестве основы кнопку-значок, которая может фиксироваться в нажатом состоянии. Такой элемент называется выключателем.
      </p>
      <p class="content">
        Кнопки-триггеры - это разновидность элементов управления. Они призваны экономить экранное пространство, к сожалению, ценой значительной дезориентации пользователя. Классический пример - размещение на одной кнопке функций воспроизведения и паузы для музыкального проигрывателя. Подводным камнем такого подхода является то, что элемент управления можно ошибочно посчитать индикатором состояния проигрывателя ("на паузе" или "идет воспроизведение"). Элемент управления может служить либо индикатором состояния, либо кнопкой переключения состояний, но не тем и другим одновременно.
      </p>
      <p class="content">
        Радиокнопки внешне похожи на флажки, но являются взаимоисключающими, то есть выбор одного из вариантов автоматически аннулирует предыдущий выбор. В каждый момент времени может быть выбрана только одна кнопка. Радиокнопки всегда объединяются в группы из двух или более радиокнопок, причем в каждой группе одна радиокнопка всегда выбрана. Радиокнопки всегда круглые по той же причине, по которой флажки всегда имеют квадратную форму: именно такими они были изначально.
      </p>
      <p class="img">
        <img src="./image/3.jpg" alt="img">
      </p>
      <p class="content">
        Элементы управления типа "список" позволяют осуществлять выбор из конечного множества текстовых строк, каждая из которых представляет команду, объект или признак. Подобно радиокнопкам, списки - мощный инструмент, упрощающий взаимодействие за счет устранения возможности неправильного выбора. Списки - это небольшие текстовые области с полосой прокрутки, автоматически подключаемой при необходимости.
      </p>
      <p class="img">
        <img src="./image/4.jpg" alt="img">
      </p>
      <p class="content">
        Комбо-элементы представляют собой сочетание элементов. Комбокнопка - разновидность радиокнопки со значком. Обычно она выглядит как кнопка-значок с небольшой стрелкой, но если нажать на стрелку и удерживать ее в нажатом состоянии, разворачивается меню. Комбо-список представляет собой сочетание списка и поля редактирования.
      </p>
      <p class="img">
        <img src="./image/5.jpg" alt="img">
      </p>
    </section>
    <section>
      <h3 class="title">
        Элементы ввода
      </h3>
      <p class="content">
        Элементы ввода дают пользователю возможность не только выбирать существующие сведения, но и вводить новую информацию. Самый простой элемент - поле редактирования текста (поле ввода). В эту категорию попадают также такие элементы управления, как счетчики и ползунки.
      </p>
      <p class="content">
        Счетчик состоит из небольшого поля ввода и двух прикрепленных к нему кнопок. Благодаря счетчикам грань между ограничивающими и неограничивающими элементами ввода данных становится размытой. Маленькие кнопки со стрелками позволяют пользователю изменять значение в поле редактирования небольшими шагами. Эти шаги могут выполняться до определенного предела: значение не может превысить максимум, установленный программой, или стать меньше установленного минимума. Если пользователь пожелает ввести определенное число, он может сделать это за счет прямого ввода числа в поле редактирования.
      </p>
      <p class="img">
        <img src="./image/6.jpg" alt="img">
      </p>
      <p class="content">
        Рукоятки и ползунки очень эффективно расходуют экранное пространство, и оба этих элемента управления замечательно справляются с задачей обеспечения визуальной обратной связи по настройкам. Ползунки и рукоятки применяются в основном в качестве ограничивающих элементов управления ввода. Например, ползунки - превосходное средство для действий, связанных с масштабированием.
      </p>
      <p class="img">
        <img src="./image/7.jpg" alt="img">
      </p>
    </section>
    <section>
      <h3 class="title">
        Элементы управления отображением
      </h3>
      <p class="content">
        Вероятно, самый простой элемент управления отображением - элемент вывода текстовой информации, который отображает текстовое сообщение в некоторой позиции на экране. Он предоставляет текстовые метки для других элементов управления и выводит данные, которые не могут или не должны быть изменены пользователем. Единственная серьезная проблема этого элемента состоит в том, что он зачастую используется там, где должны присутствовать элементы ввода (и наоборот).
      </p>
      <p class="content">
        Полосы прокрутки служат важной цели - они позволяют осмысленным образом помещать большие объемы информации внутри рамок окон и панелей. К сожалению, они расходуют экранное пространство и ими сложно манипулировать. Однако замечательное преимущество полосы
прокрутки состоит в создании контекста текущего положения в окне. Бегунок полосы прокрутки указывает текущее положение и нередко «масштаб» территории доступной для прокрутки.
      </p>
      <p class="content">
        Разделители - удобный инструмент для разделения главного окна приложения на несколько связанных между собой панелей, в каждой из которых можно просматривать, изменять или переносить ту или иную информацию. Подвижные разделители всегда должны сообщать о своей подвижности посредством изменения формы курсора.
      </p>
      <p class="content">
        Выдвижные панели - это панели приложения, которые можно открывать и закрывать в одно действие. Выдвижные панели - замечательное место для элементов управления и функций, которые используются совместно с основной рабочей областью приложения, но не столь часто.
      </p>
      <p class="img">
        <img src="./image/8.jpg" alt="img">
      </p>
    </section>
    <section>
      <h3 class="title">
        Использование ресурсов
      </h3>
      <p class="content">При разработке мобильных приложений необходимо выработать привычку отделять ресурсы приложения от кода. К ресурсам приложения могут относиться: изображения, строки, цвета, компоновки элементов пользовательского интерфейса (layout) и т. д. Отделение ресурсов от кода позволяет использовать альтернативные ресурсы для различных конфигураций устройств: язык, разрешение экрана и т. д. Для обеспечения совместимости с различными конфигурациями, ресурсы необходимо сгруппировать в директории по типу ресурсов и конфигурации устройства, полученные директории поместить в папку res/. Для любого типа ресурсов можно определить две группы. Первая определяет ресурсы, которые будут использоваться независимо от конфигурации устройства или в том случае, когда под конфигурацию нет подходящих альтернативных ресурсов. Эта группа называется ресурсы по умолчанию (default). Вторая группа определяет ресурсы, подходящие для определенной конфигурации устройства, размещается в директории с названием, обозначающим данную конфигурацию. Такие ресурсы называются альтернативными.</p>
      <p class="content">
       <span> Каждый тип ресурсов необходимо размещать в специальной поддиректории папки res/. Рассмотрим основные из этих поддиректорий:</span>
        <ol class="list">
          <li> animator/ - содержит XML файлы, которые определяют свойства анимации;</li>
          <li> anim/ - содержит XML файлы, которые определяют анимацию преобразований</li>
          <li> color/ - содержит XML файлы, которые определяют списки цветов;</li>
          <li> drawable/ - содержит графические файлы или XML файлы, которые компилируются в графические ресурсы;</li>
          <li> layout/ - содержит XML файлы, которые определяют компоновку элементов пользовательского интерфейса;</li>
          <li> menu/ - содержит XML файлы, которые определяют все меню приложения</li>
          <li> values/ - содержит XML файлы, которые определяют простые значения, таких ресурсов как, строки, числа, цвета.</li>
      </p>
      <p class="content">Следует отметить, что файлы ресурсов нельзя размещать в папку res/ напрямую, они обязательно должны размещаться в соответствующем каталоге, иначе будет выдана ошибка компиляции.</p>
    </section>
    <section>
      <h3 class="title">
        Механизмы взаимодействия пользовательских окон и способы передачи данных
      </h3>
      <p class="content">
        Для мобильных приложений главным ограничением является размер экрана устройства. Очень часто невозможно разместить все элементы полнофункционального приложения так, чтобы их можно было увидеть одновременно. Очевидным решением этой проблемы является разделение интерфейса на части по какому-либо принципу. Основные пути решения этой проблемы:
        <ol class="list">
          <li> onCreate() - метод, вызываемый системой при создании активности. В реализации метода необходимо инициализировать основные компоненты активности и в большинстве случаев вызвать метод setContentView() для подключения соответствующего XML-файла компоновки (layout file). После метода onCreate() всегда вызывается метод onStart().</li>
          <li> onRestart() - метод, вызываемый системой при необходимости запустить приостановленную активность. После этого метода всегда вызывается метод onStart().</li>
          <li> onStart() - метод, вызываемый системой непосредственно перед тем, как активность станет видимой для пользователя. После этого метода вызывается onResume().</li>
          <li> onResume() - метод, вызываемый системой непосредственно перед тем, как активность начнет взаимодействовать с пользователем. После этого метода всегда вызывается onPause().</li>
          <li> onDestroy() - метод, вызываемый системой перед уничтожением активности. Этот метод вызывается либо когда активность завершается, либо когда система уничтожает активность, чтобы освободить ресурсы. Можно различать эти два сценария с помощью метода isFinishing(). Это последний вызов, который может принять активность.</li>
          <li> onStop() - метод, вызываемый системой, когда активность становится невидимой для пользователя. После этого метода вызывается либо onRestart(), если активность возвращается к взаимодействию с пользователем, либо onDestroy(), если активность уничтожается.</li>
          <li> onDestroy() - метод, вызываемый системой перед уничтожением активности. Этот метод вызывается либо когда активность завершается, либо когда система уничтожает активность, чтобы освободить ресурсы. Можно различать эти два сценария с помощью метода isFinishing(). Это последний вызов, который может принять активность.</li>
        </ol>
      </p>
      <p class="img">
        <img src="./image/9.jpg" alt="img">
      </p>
      <p class="content">
        <span>Фактически активность может существовать в одном из трех состояний:</span>
        <ol class="list">
          <li>Выполняется (running). Активность находится на переднем плане и удерживает фокус ввода. Если внимательно рассмотреть можно заметить, что в это состояние активность попадает после вызова метода onResume(). Пока активность находится в этом состоянии ее процесс не может быть уничтожен системой.</li>
          <li>Приостановлена. Активность частично видима, однако фокус ввода потерян. В это состояние активность попадает после вызова метода onPause(). В этом состоянии активность поддерживается в "боевой готовности т.е. в любой момент может получить фокус ввода и стать активной. Однако в этом состоянии процесс активности может быть уничтожен системой, в случае экстремальной нехватки памяти.</li>
          <li>Остановлена. Активность полностью невидима. В это состояние активность попадает после вызова метода onStop(). В этом состоянии активность может быть "вызвана к жизни она сохраняет все состояния и необходимую для восстановления информацию, однако процесс активности может быть уничтожен, если память понадобится для других целей.</li>
        </ol>
      </p>
      <p class="content"></p>
      <p class="content"></p>
    </section>
    <section>
      <h3 class="title">
        Создание пользовательских окон, реализация их функциональности и обработка событий
      </h3>
      <p class="content">
        <span>Приложения, содержащие несколько активностей, используются в самых разных сферах. При проектировании такого приложения следует уделить большое внимание распределению его функционала по разным активностям. С одной стороны, не стоит перегружать экран информацией, а с другой - нужна ли активность, содержащая только одно поле для ввода? Может быть, стоит ее заменить диалоговым окном? Существует два основных способа переключения между активностями:</span>
        <ol class="list">
         <li>При помощи кнопок и других элементов управления. Не требует перестройки мышления у программистов, которые имеют большой опыт разработки десктопных приложений, а так же у пользователей, привыкших к действиям в стиле "нажал на кнопку, получил результат". Однако этот способ не является наиболее подходящим для сенсорных экранов и требует от опытного пользователя смартфона совершения лишних движений.</li>
         <li>С использованием сенсорного экрана смартфона. Основная идея состоит в том, что весь экран мобильного устройства можно использовать в качестве управляющего элемента, и, нажимая на отдельные его участки, пользователь может инициировать те или иные действия.</li>
        </ol>
      </p>
      <p class="content">
        Существует ряд правил расположения интерфейсных элементов в зависимости от их важности. Так, кнопку, выполняющую важное действие (например, отправку письма), не стоит располагать в том месте, где она может быть случайно нажата. В то же время управляющие элементы, используемые наиболее часто, должны быть расположены наиболее удобным для нажатия образом. Скорее всего, перемещение между активностями будет использоваться не очень часто, поэтому рекомендуется располагать кнопки, управляющие этими действиями, в верхней части экрана. Одновременно с этим неплохо продублировать нажатия кнопок перелистыванием между активностями.
      </p>
      <p class="content">
        Существует способ разместить на активности больше элементов, чем одновременно помещается на экран, иными словами, отображать по очереди несколько экранов, используя только одну активность. В этом случае не нужно править файл манифеста - активность только одна. Однако для каждого экрана необходимо сделать свой xml-файл с его описанием. Такой способ размещения элементов удобен и программисту, и пользователю. Разработчик может организовать перемещение между частями активности и с помощью кнопок, и с помощью перелистывания.
      </p>
      <p class="img">
        <img src="./image/10.jpg" alt="img">
      </p>
    </section>
    <section>
      <h3 class="title">
        Компонент Intent. Использование компонента Intent
      </h3>
      <p class="content">
        Объекты-экземпляры класса Intent используются для передачи сообщений между основными компонентами приложений. Известно, что три из четырех основных компонентов: активности, сервисы и приемники широковещательных сообщений, могут быть активированы с помощью
сообщений, которые называются намерениями. Такие сообщения являются инструментом позднего связывания компонентов одного или нескольких приложений. Экземпляр класса Intent представляет собой структуру данных, содержащую описание операции, которая должна быть выполнена, и обычно используется для запуска активности или сервиса. В случае с приемниками широковещательных сообщений объект Intent содержит описание события, которое произошло или было объявлено.
      </p>
      <p class="content">
        Для каждого типа компонентов существуют свои механизмы передачи намерений.
        <ol class="list">
          <li>Чтобы запустить активность или вызвать у работающей активности новое действие, необходимо передать объект-намерение в метод Context.startActivity() или Activity.startActivityForResult().</li>
          <li>Чтобы запустить сервис или доставить новые инструкции работающему сервису, необходимо передать объект-намерение в метод Context.startService(). Также объект-намерение может быть передан в метод Context.bindService(), чтобы связать между собой вызывающий компонент и сервис.</li>
          <li>Чтобы доставить объект-намерение всем заинтересованным приемникам широковещательных сообщений, необходимо передать его в любой из широковещательных методов: Context.sendOrderedBroadcast(), Context.sendStickyBroadcast(), Context.sendBroadcast().</li>
        </ol>
      </p>
      <p class="content">
        В каждом случае система Android в ответ на намерение находит соответствующий компонент: активность, сервис или множество широковещательных приемников и запускает его если необходимо. В этой системе сообщений не случается накладок: сообщение-намерение, отправленное определенному компоненту, будет получено именно этим компонентом и никем другим.
      </p>
      <p class="img">
        <img src="./image/11.jpg" alt="img">
      </p>
    </section>
  </body>
</html>
